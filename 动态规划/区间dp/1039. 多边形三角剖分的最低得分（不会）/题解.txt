我的思路错了
我是这么想的嘛，如果前面的都已经处理好了
那么多出来的一个，只要在前面的状态下求就好了

然后我想着，求加了一个n
我将前面一段区间划分为ij
那么，不就是求
0——i——n
i——j——n
j——n-1——n
这三段嘛
然后很自然的列出了转移方程，但是我忘记了一个问题
这只是求dp[0][n]的，也就是，中间的状态都没更新呀！

所以以后你如果想求dp，怎么都要dp[i][j]吧？
这样才可以更新状态呀！

然后我就看了题解，怎么说呢
人家真的太厉害了。
想要求dp[i][j]，那么我可以先找k，更新这个区间
dp[i][j] = Math.min(dp[i][j], dp[i][k]+dp[k][j]+A[i]*A[j]*A[k]);
转移方程我可以理解，但是有个问题
先后顺序我不能理解
然后我开始写代码，然后各种报错
最后我意识到，如果我一开始的顺序是从0-n的话
那么直接算出dp[0][n]了，所以顺序不能这样
然后我就换了顺序，就得出结果了


但是！

我看了下别人的代码，顺序都没问题呀！

区间dp都是这么做的。
我得总结一下下。
大概就是，大区间转化为小区间，先求小区间，然后合并成大区间

所谓的区间dp
就是相当于：
先划分成小区间，也就是len从小到大，这是最外层
然后找到区间的起始点，这是第二层
由于知道起点，知道长度，那么也知道了结束点
第三层就是遍历起点和终点间的分割点
至此，区间dp就完成了。