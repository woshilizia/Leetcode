我用了o(n^2)的方法，想法就是——
其实我感觉，动态规划有点像数学归纳法呀！
就我们要做到的不就是，先找到一个起始条件——初始化
然后找到归纳公式——动态转移方程嘛

那么现在，
假设前面全部都已经处理完毕了。
既然如此，就是求dp[n]的大小了。
首先，dp[n]代表着，n的位置一定取了。
那么我要求一个最大的，只要找到前面比nums[n]小的位置的dp，找到其中的最大值就好了。
so简单，当然求o(nlogn)这个方法，我得琢磨下



很好很强大，看了人家的代码，果然很厉害呀。
具体来说，就是更新数组
数组中存的是每个长度中数字最小的数字，不断更新就好了呀QAQ
这个想法真的不错，有点巧妙绝伦啦。

我得记住这个想法或者说思路
来一个数组，每次更新
逆向思维吧。


